---
layout: post
title: 'Hacking the java compiler: using anonymous subclasses as closures'
---
<p>UPDATE: new more comprehensive post on this subject: <a href="http://simonwoodside.com/weblog/2009/7/7/a_little_bit_more_serious/">Closures with return values in Java</a>.</p><p>In Java, closures/first-order functions are not a language feature. However, as everyone knows, you can effectively get a first-order function by using an anonymous subclass instead. Something like this:</p><pre><br />class MyClosure {<br />  void run() {} // override this<br />}<br />void doSomethingClosureLike() {<br />  MyClosure closure = new MyClosure() { void run() { System.out.println("We're inside a closure!"); }};<br />  runTheClosure(closure);<br />}<br />void runTheClosure(MyClosure closure) {<br />  closure.run();<br />}<br />// will print We're inside a closure!</pre><p>Anyway, it's simple enough, you pass the class instead of the function and there's a little extra verbage but it works!</p><p>Also you get closure-like functionality, because inside run() you can access variables from outwhere where you created it. E.g.:</p><pre><br />void doSomethingCooler() {<br />  final String myString = "Foo!";<br />  MyClosure closure = new MyClosure() { void run() { System.out.println("The string is: " + myString); }};<br />  runTheClosure(closure);<br />}<br />// will print The string is: Foo!</pre><p>You can also access global variables that change over time, and the closure will use whatever is the current value WHEN THE CLOSURE RUNS.</p><p>There's just one small annoying thing, which is this particularly annoying compiler message: </p><pre>local variable (WHATEVER) is accessed from within inner class; needs to be declared final</pre><p>If you were do change myString to not be final, you'd get that error. Bummer. You could make myString a global variable and that would work, but that's stupid. There is a better way. Try this: <strong>UPDATE: This doesn't work, see new version at the bottom, thanks commenter the.d-stro.</strong></p><pre>void doSomethingCooler() {<br />  String myString = "Foo!";<br />  final String myStringFinal = myString;<br />  myString.concat(" Bar!");<br />&#160; MyClosure closure = new MyClosure() { void run() { System.out.println("The string is:" + myStringFinal); }};<br /> &nbsp;runTheClosure(closure);<br />}<br />// will print Foo! Bar!</pre><p>Now you can even change myString after you assign myStringFinal, because Java, although they say it doesn't use pointers, really does use pointers. I.e. it passes by reference. So, myStringFinal is actually just a reference to myString, and keeps pointing to it even when you change the contents of myString.</p><p>You can CHANGE it (like using concat()) but you CAN'T reassign it. That will break the pointers. It makes sense if you think about it -- myString will have a new memory address, and myStringFinal will still be pointing to the old memory address (and the old string value). So, this won't work:</p><pre>myString = "won't work"; // breaks myStringFinal</pre><p>You can use this technique with any object (but not primitives like int).</p><p><strong>UPDATE</strong></p><p>The last source block is wrong because java Strings are immutable. Here's an example that will work as advertised:</p><pre><br />  void doSomethingCoolest() {<br />    StringBuffer myString = new StringBuffer("Foo!");<br />    final StringBuffer myStringFinal = myString;<br />    myString.append(" Bar!");<br />    MyClosure closure = new MyClosure() { void run() { System.out.println("The string is: " + myStringFinal); }};<br />    runTheClosure(closure);<br />  }<br />  // will print The string is: Foo! Bar!</pre>
